#!/usr/bin/env python3
import os

import ldap
import ldif
from ldap.modlist import addModlist
import pytest

LDAP_CONNECTION_STRING = os.getenv('TEST_LDAP_CONNECTION_STRING')
PASSWORD = os.getenv('TEST_PASSWORD')
SUFFIX = os.getenv('TEST_SUFFIX')
ACI_LDIF = os.getenv('TEST_ACI_LDIF')
IMPORT_SCHEMA = os.getenv('TEST_IMPORT_SCHEMA') is not None
IMPORT_SCHEMA_DONE = False

if LDAP_CONNECTION_STRING is None or len(LDAP_CONNECTION_STRING) <= 0:
	print("Set the env variable TEST_LDAP_CONNECTION_STRING")
	exit(1)
if PASSWORD is None or len(PASSWORD) <= 0:
	print("Set the env variable TEST_PASSWORD")
	exit(1)
if SUFFIX is None or len(SUFFIX) <= 0:
	print("Set the env variable TEST_SUFFIX")
	exit(1)
if ACI_LDIF is None or len(ACI_LDIF) <= 0:
	print("Set the env variable TEST_ACI_LDIF")
	exit(1)


class LdifReaderAdd(ldif.LDIFParser):
	def __init__(self, input_file, conn: ldap.ldapobject.SimpleLDAPObject):
		self.conn = conn
		super().__init__(input_file)

	def handle(self, dn, entry):
		addthis = addModlist(entry)
		self.conn.add_s(dn, addthis)


class LdifReaderThatUsesModifyInsteadOfAdd(ldif.LDIFParser):
	def __init__(self, input_file, conn: ldap.ldapobject.SimpleLDAPObject):
		self.conn = conn
		super().__init__(input_file)

	def handle(self, dn, entry):
		addthis = addModlist(entry)
		addthis_but_in_the_other_format = []
		for t in addthis:
			addthis_but_in_the_other_format.append((ldap.MOD_ADD, t[0], t[1]))
		self.conn.modify_s(dn, addthis_but_in_the_other_format)


class LdifReaderThatParsesLdifFilesWithChangetype(ldif.LDIFParser):
	def __init__(self, input_file, conn: ldap.ldapobject.SimpleLDAPObject):
		self.conn = conn
		super().__init__(input_file)

	def handle(self, dn, entry):
		addthis = addModlist(entry)
		addthis_but_in_the_other_format = []
		mod = ldap.MOD_ADD
		for t in addthis:
			if t[0] == 'changetype':
				continue
			if t[0] == 'replace':
				mod = ldap.MOD_REPLACE
				continue
			addthis_but_in_the_other_format.append((mod, t[0], t[1]))
		self.conn.modify_s(dn, addthis_but_in_the_other_format)


def recursive_delete_subtree(conn: ldap.ldapobject.SimpleLDAPObject, base_dn: str):
	search = conn.search_s(base_dn, ldap.SCOPE_ONELEVEL)
	for dn, _ in search:
		recursive_delete(conn, dn)


# https://stackoverflow.com/a/29371688
def recursive_delete(conn: ldap.ldapobject.SimpleLDAPObject, base_dn: str):
	search = conn.search_s(base_dn, ldap.SCOPE_ONELEVEL)
	for dn, _ in search:
		recursive_delete(conn, dn)
	conn.delete_s(base_dn)


def save_acis(conn: ldap.ldapobject.SimpleLDAPObject, base_dn: str):
	search = conn.search_s(base_dn, ldap.SCOPE_BASE, None, ['aci'])
	return search[0][1]


@pytest.fixture(autouse=True)
def reset_database():
	global IMPORT_SCHEMA, IMPORT_SCHEMA_DONE

	with LdapConnection("cn=Directory Manager", PASSWORD) as conn:
		# These entries have been reverse engineered by looking at the LDAP commands generated by this command:
		# dsconf -D "cn=Directory Manager" localhost backend create --create-suffix --suffix="dc=example,dc=test" --be-name="userRoot"
		root = 'testAcis'
		try:
			conn.add_s(f'cn={root},cn=ldbm database,cn=plugins,cn=config', [
				('objectClass', [b'top', b'extensibleObject', b'nsBackendInstance']),
				('cn', [root.encode()]),
				('nsslapd-suffix', [SUFFIX.encode()]),
			])
		except ldap.ALREADY_EXISTS:
			pass
		try:
			# Why \\, instead of \\2C? Dunno, but Apache Directory Studio displays it like that in any case.
			suffix_ultra_escaped = SUFFIX.replace(',', '\\,').replace('=', '\\3D')
			suffix_escaped = ldap.dn.escape_dn_chars(SUFFIX)
			conn.add_s(f'cn={suffix_ultra_escaped},cn=mapping tree,cn=config', [
				('objectClass', [b'top', b'extensibleObject', b'nsMappingTree']),
				('cn', [SUFFIX.encode(), suffix_escaped.encode()]),
				('nsslapd-state', [b"backend"]),
				('nsslapd-backend', [root.encode()]),
			])
		except ldap.ALREADY_EXISTS:
			pass
		try:
			conn.add_s(SUFFIX, [
				('objectClass', [b'top', b'domain']),
				('dc', [SUFFIX.split(',')[0].split('=')[1].encode()]),
				('description', [SUFFIX.encode()]),
				('aci', [
					b'(targetattr="dc || description || objectClass")(targetfilter="(objectClass=domain)")(version 3.0; acl "Enable anyone domain read"; allow (read, search, compare)(userdn="ldap:///anyone");)']),
			])
		except ldap.ALREADY_EXISTS:
			pass

		things = (
			f'ou=Groups,{SUFFIX}',
			f'ou=People,{SUFFIX}',
			f'ou=Services,{SUFFIX}',
			f'ou=Invites,{SUFFIX}',
		)

		for thing in things:
			try:
				recursive_delete(conn, thing)
			except ldap.NO_SUCH_OBJECT:
				pass

		if IMPORT_SCHEMA and not IMPORT_SCHEMA_DONE:
			# We need to split schemas and build LDIF files on the fly: https://stackoverflow.com/a/69899256
			# Also, each schema may depend on another one
			with open('schema_tmp_objectClasses.ldif', 'w') as ldif_oc, open('schema_tmp_attributeTypes.ldif', 'w') as ldif_at:
				# Write the header
				ldif_at.write("version: 1\n\ndn: cn=schema\n")
				ldif_oc.write("version: 1\n\ndn: cn=schema\n")
				for schema in ('../97schac.ldif', '../98ssh.ldif', '../98telegram.ldif', '../98weeeopen.ldif'):
					with open(schema, 'r') as file:
						current_text = "version: 1\n\n"
						current_section = None
						for line in file:
							low = line.lower()
							if low.startswith("objectclasses: ") or low.startswith("attributetypes: "):
								if not current_section or not low.startswith(current_section):
									if current_section:
										if current_section == "objectclasses: ":
											ldif_oc.write(current_text)
										else:
											ldif_at.write(current_text)
									current_text = ""
									current_section = "objectclasses: " if low.startswith("objectclasses: ") else "attributetypes: "
							current_text += line
						if current_section == "objectclasses: ":
							ldif_oc.write(current_text)
						elif current_section == "attributetypes: ":
							ldif_at.write(current_text)
						else:
							raise RuntimeError(f"Not a valid schema file: {schema}")

			with open('schema_tmp_attributeTypes.ldif', 'rb') as f:
				parser = LdifReaderThatUsesModifyInsteadOfAdd(f, conn)
				parser.parse()
			with open('schema_tmp_objectClasses.ldif', 'rb') as f:
				parser = LdifReaderThatUsesModifyInsteadOfAdd(f, conn)
				parser.parse()

			IMPORT_SCHEMA_DONE = True

		# Absolutely required under every circumstance, thankfully it works even though it's not officially supported
		conn.modify_s('cn=config', [(ldap.MOD_REPLACE, 'nsslapd-dynamic-plugins', b'on')])
		conn.modify_s('cn=MemberOf Plugin,cn=plugins,cn=config', [(ldap.MOD_REPLACE, 'nsslapd-pluginEnabled', b'on')])

		with open('everything.ldif', 'rb') as f:
			parser = LdifReaderAdd(f, conn)
			parser.parse()

		with open(ACI_LDIF, 'rb') as f:
			parser = LdifReaderThatParsesLdifFilesWithChangetype(f, conn)
			parser.parse()

		with open('../policies.ldif', 'rb') as f:
			parser = LdifReaderThatParsesLdifFilesWithChangetype(f, conn)
			parser.parse()

	# for dn, values in zip(things, acis):
	# 	conn.modify_s(dn, ldap.modlist.modifyModlist({}, values))


@pytest.fixture()
def example_user():
	return [
		('objectClass',
		 [b'telegramAccount', b'schacPersonalCharacteristics', b'top', b'person', b'organizationalPerson',
		  b'inetOrgPerson', b'weeeOpenPerson']),
		('cn', [b'Example User']),
		('sn', [b'User']),
		('mobile', [b'+39010101011011']),
		('telegramID', [b'1337']),
		('uid', [b'example.user']),
		('weeeOpenUniqueId', [b'798aa6f8-7a9a4b96-931da47d-669c0674']),
	]


@pytest.fixture()
def example_user_with_password(example_user):
	example_user.append(('userPassword', [b'{PBKDF2_SHA256}AAAnENBOg9Pr7VfWGJEKpYaCNCvCTpe8xZAeCkcneca7Gir'
	                                      b'KbHwLQ24j9I7u2c1vXSPnsWZzd4OoKETdAJZzxUhFJvlqBI7P71M7ts+t9QHJoo4Yx5TcSOCoz2'
	                                      b'zNGtnjlQqi+rptAG5yNmiYJ1jULvXPHkNtr6Ckkwr3SgcpKWpJDLGLXNuhJkww/jv7D0eC/I9jz'
	                                      b'nkOO5lJwMBKmxuWwxLjFjJ7MK1YGFPpUkxZuam3iy2X6kmPEQXCZdhE9dgATjK5I2WlgQOAZ34H'
	                                      b'ouJHxuzV83JG+SJnYpE5rzDfuSmhaCZfmwWQpZCPNU1QKx+CrAeUht/Vrk4iM7ScJM+si/eTOaK'
	                                      b'OCVGvpr2xZEvIy0xOXTAF6UW5Acos1a8jtKBJf4zmlsfKGByXQPNj38bd6CyVdKie1R6OT+YtPN'
	                                      b'EkmrcSJCNc']))
	return example_user


@pytest.fixture()
def example_group():
	return [
		('objectClass', [b'top', b'organizationalunit']),
		('cn', [b'Example Group'])
	]


@pytest.fixture()
def empty_container():
	return [
		('objectClass', [b'top', b'inetOrgPerson']),
		('cn', [b'Empty'])
	]


class LdapConnection:
	def __init__(self, bind_dn, password):
		self.bind_dn = bind_dn
		self.password = password

	def __enter__(self):
		self.conn = ldap.initialize(LDAP_CONNECTION_STRING)

		self.conn.protocol_version = ldap.VERSION3
		# l.set_option(ldap.OPT_X_TLS, 1)
		self.conn.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_NEVER)  # TODO: change in production
		self.conn.set_option(ldap.OPT_X_TLS_NEWCTX, 0)  # This must be the last option after TLS options and is required
		self.conn.start_tls_s()
		self.conn.simple_bind_s(self.bind_dn, self.password)
		return self.conn

	def __exit__(self, exc_type, exc_val, exc_tb):
		self.conn.unbind_s()


def test_deny_read_special():
	with LdapConnection(f"cn=Test,ou=Services,{SUFFIX}", "asd") as conn:
		assert True, 'Test user can connect'

		result = conn.search_s(SUFFIX, ldap.SCOPE_SUBTREE, '(objectClass=*)', ['*'])
		for dn, attributes in result:
			assert set(attributes.keys()) == {'objectClass'}, 'Only objectClass is returned'


def test_deny_self_special():
	test_dn = f"cn=Test,ou=Services,{SUFFIX}"
	with LdapConnection(test_dn, "asd") as conn:
		result = conn.search_s(test_dn, ldap.SCOPE_SUBTREE, '(objectClass=*)', ['*'])
		for dn, attributes in result:
			assert set(attributes.keys()) == {'objectClass'}, 'Only objectClass is returned'

		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.modify_s(test_dn, [(ldap.MOD_ADD, 'cn', b'testing that this value never appears')])


# Crauto can change passwords
@pytest.mark.parametrize("bind_dn", [f"cn=Crauto,ou=Services,{SUFFIX}"])
def test_allow_password_change(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		conn.modify_s(f"uid=test.user,ou=People,{SUFFIX}", [
			(ldap.MOD_REPLACE, 'userPassword', b'asdasdasdasdasdasd')
		])


# Those who can change passwords, can't replace them with passwords that violate constraints
@pytest.mark.parametrize("bind_dn", [f"cn=Crauto,ou=Services,{SUFFIX}"])
def test_fail_password_change_constraint(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.CONSTRAINT_VIOLATION):
			conn.modify_s(f"uid=test.user,ou=People,{SUFFIX}", [
				(ldap.MOD_REPLACE, 'userPassword', b'a')
			])


@pytest.mark.parametrize("bind_dn",
	[f"uid=test2.user2,ou=People,{SUFFIX}", f"cn=Test,ou=Services,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}",
	 f"uid=test.user,ou=People,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"uid=test.hr,ou=People,{SUFFIX}"])
def test_deny_password_change(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.modify_s(f"uid=test.user,ou=People,{SUFFIX}", [
				(ldap.MOD_REPLACE, 'userPassword', b'asdasdasdasdasdasd')
			])


@pytest.mark.parametrize("bind_dn",
	[f"uid=test.user,ou=People,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"cn=Test,ou=Services,{SUFFIX}",
	 f"cn=Nextcloud,ou=Services,{SUFFIX}", f"uid=test.hr,ou=People,{SUFFIX}"])
def test_deny_password_change_sso_service(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.modify_s(f"cn=Keycloak,ou=Services,{SUFFIX}", [
				(ldap.MOD_REPLACE, 'userPassword', b'lol')
			])


@pytest.mark.parametrize("bind_dn",
	[f"uid=test.user,ou=People,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"cn=Test,ou=Services,{SUFFIX}",
	 f"cn=Nextcloud,ou=Services,{SUFFIX}", f"uid=test.hr,ou=People,{SUFFIX}"])
def test_deny_password_change_service(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.modify_s(f"cn=Test,ou=Services,{SUFFIX}", [
				(ldap.MOD_REPLACE, 'userPassword', b'lol')
			])


@pytest.mark.parametrize("bind_dn",
	[f"uid=test.user,ou=People,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"cn=Test,ou=Services,{SUFFIX}",
	 f"cn=Nextcloud,ou=Services,{SUFFIX}", f"uid=test.hr,ou=People,{SUFFIX}"])
def test_deny_password_change_ou(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.modify_s(f"ou=Services,{SUFFIX}", [
				(ldap.MOD_REPLACE, 'userPassword', b'lol')
			])


@pytest.mark.parametrize("bind_dn",
	[f"uid=test.user,ou=People,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"cn=Test,ou=Services,{SUFFIX}",
	 f"cn=Nextcloud,ou=Services,{SUFFIX}", f"uid=test.hr,ou=People,{SUFFIX}"])
def test_deny_info_change_user(bind_dn):
	test_dn = f"uid=test.user,ou=People,{SUFFIX}"
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.modify_s(test_dn, [
				(ldap.MOD_REPLACE, 'mobile', b'+392222222')
			])


def test_allow_info_change_crauto():
	test_dn = f"uid=test.user,ou=People,{SUFFIX}"
	value = b'+392222222'
	with LdapConnection(f"cn=Crauto,ou=Services,{SUFFIX}", "asd") as conn:
		conn.modify_s(test_dn, [(ldap.MOD_REPLACE, 'mobile', value)])
		result = conn.search_s(test_dn, ldap.SCOPE_BASE, None, ['mobile'])
		assert len(result) > 0, 'mobile exists'
		assert result[0][1]['mobile'][0] == value, 'mobile has the expected value'


def test_allow_read_crauto():
	with LdapConnection(f"cn=Crauto,ou=Services,{SUFFIX}", "asd") as conn:
		result = conn.search_s(f"uid=test.user,ou=People,{SUFFIX}", ldap.SCOPE_BASE, None, ['*', '+'])
		assert len(result) > 0, 'User is readable'
		expected = {
			'memberOf',
			'objectClass',
			'givenName',
			'mail',
			'cn',
			'sn',
			'mobile',
			'telegramID',
			'uid',
			'createTimestamp',
			'modifyTimestamp',
		}
		assert set(result[0][1].keys()) == expected, 'All expected attributes are present'


def test_allow_read_nextcloud():
	with LdapConnection(f"cn=Nextcloud,ou=Services,{SUFFIX}", "asd") as conn:
		result = conn.search_s(f"uid=test.user,ou=People,{SUFFIX}", ldap.SCOPE_BASE, None, ['*', '+'])
		assert len(result) > 0, 'User is readable'
		expected = {
			'memberOf',
			'objectClass',
			'cn',
			'sn',
			'givenName',
			'uid',
			'mail',
			'entryid',
			'nsUniqueId',
			'createTimestamp',
			'modifyTimestamp',
			'creatorsName',
			'modifiersName',
			'parentid',
			'entrydn',
			'weeeOpenUniqueId',
		}
		assert set(result[0][1].keys()) == expected, 'All expected attributes are present'


@pytest.mark.parametrize("bind_dn",
	[f"cn=Crauto,ou=Services,{SUFFIX}", f"uid=test.user,ou=People,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}",
	 f"cn=Test,ou=Services,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}", f"uid=test.hr,ou=People,{SUFFIX}"])
def test_deny_password_read(bind_dn):
	with LdapConnection(f"cn=Crauto,ou=Services,{SUFFIX}", "asd") as conn:
		result = conn.search_s(bind_dn, ldap.SCOPE_BASE, None, ['userPassword'])
		assert len(result) == 0 or len(result[0][1]) == 0, 'No attributes returned'


def test_allow_read_sso():
	with LdapConnection(f"cn=Keycloak,ou=Services,{SUFFIX}", "asd") as conn:
		result = conn.search_s(f"uid=test.user,ou=People,{SUFFIX}", ldap.SCOPE_BASE, None, ['*', '+'])
		assert len(result) > 0, 'User is readable'
		expected = {
			'modifyTimestamp',
			'modifiersName',
			'memberOf',
			'objectClass',
			'cn',
			'uid',
			'creatorsName',
			'createTimestamp',
			'mail',
			'nsUniqueId',
			'parentid',
			'entryid',
			'entrydn',
			'weeeOpenUniqueId',
		}
		assert set(result[0][1].keys()) == expected, 'All expected attributes are present'


@pytest.mark.parametrize("bind_dn",
	[f"cn=Keycloak,ou=Services,{SUFFIX}", f"uid=test.user,ou=People,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}"])
def test_deny_add_user(bind_dn, example_user):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.add_s(f"uid=example.user,ou=People,{SUFFIX}", example_user)


def test_allow_add_user_crauto(example_user):
	with LdapConnection(f"cn=Crauto,ou=Services,{SUFFIX}", "asd") as conn:
		conn.add_s(f"uid=example.user,ou=People,{SUFFIX}", example_user)
		result = conn.search_s(f"uid=example.user,ou=People,{SUFFIX}", ldap.SCOPE_BASE, None, ['*'])
		assert len(result) > 0, 'User has been added'


@pytest.mark.parametrize("bind_dn",
	[f"cn=Keycloak,ou=Services,{SUFFIX}", f"uid=test.user,ou=People,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}"])
def test_deny_delete_user(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.delete_s(f"uid=test2.user2,ou=People,{SUFFIX}")


def test_allow_delete_user_crauto():
	with LdapConnection(f"cn=Crauto,ou=Services,{SUFFIX}", "asd") as conn:
		conn.delete_s(f"uid=test2.user2,ou=People,{SUFFIX}")
		result = conn.search_s(f"uid=test2.user2,ou=People,{SUFFIX}", ldap.SCOPE_BASE, None, ['*'])
		assert len(result) == 0, 'User is gone'


@pytest.mark.parametrize("bind_dn",
	[f"cn=Crauto,ou=Services,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"uid=test.user,ou=People,{SUFFIX}",
	 f"uid=test.hr,ou=People,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}"])
def test_deny_add_group(bind_dn, example_group):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.add_s(f"cn=Example Group,ou=Groups,{SUFFIX}", example_group)


@pytest.mark.parametrize("bind_dn",
	[f"cn=Crauto,ou=Services,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"uid=test.user,ou=People,{SUFFIX}",
	 f"uid=test.hr,ou=People,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}"])
def test_deny_delete_group(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.delete_s(f"cn=People,ou=Groups,{SUFFIX}")


@pytest.mark.parametrize("bind_dn",
	[f"cn=Crauto,ou=Services,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"uid=test.user,ou=People,{SUFFIX}",
	 f"uid=test.hr,ou=People,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}"])
def test_deny_add_container(bind_dn, empty_container):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.add_s(f"cn=Empty,{SUFFIX}", empty_container)


@pytest.mark.parametrize("bind_dn",
	[f"cn=Crauto,ou=Services,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"uid=test.user,ou=People,{SUFFIX}",
	 f"uid=test.hr,ou=People,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}"])
def test_deny_delete_container(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.delete_s(f"ou=People,{SUFFIX}")


@pytest.mark.parametrize("bind_dn", [f"cn=Test,ou=Services,{SUFFIX}", f"uid=test.user,ou=People,{SUFFIX}"])
def test_deny_read_group(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		result = conn.search_s(f"cn=Testers,ou=Groups,{SUFFIX}", ldap.SCOPE_BASE, None, ['ou', 'member'])
		assert len(result) == 0 or len(result[0][1]) == 0, 'No group details or members are visible'


@pytest.mark.parametrize("bind_dn",
	[f"cn=Crauto,ou=Services,{SUFFIX}", f"cn=Keycloak,ou=Services,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}"])
def test_allow_read_group(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		result = conn.search_s(f"cn=Testers,ou=Groups,{SUFFIX}", ldap.SCOPE_BASE, None, ['cn', 'member'])
		attributes = result[0][1]
		assert len(attributes) > 0, 'Some attributes are found'
		assert 'cn' in attributes, 'ou is readable'
		assert 'member' in attributes, 'member is readable'
		assert len(attributes['member']) > 0, 'Group has some members'


@pytest.mark.parametrize("bind_dn",
	[f"cn=Keycloak,ou=Services,{SUFFIX}", f"cn=Test,ou=Services,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}",
	 f"uid=test.user,ou=People,{SUFFIX}"])
def test_deny_add_to_group(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.modify_s(f"cn=Testers,ou=Groups,{SUFFIX}",
				[(ldap.MOD_ADD, 'member', bytes(f'uid=test.hr,ou=People,{SUFFIX}', 'utf8'))])


@pytest.mark.parametrize("bind_dn",
	[f"cn=Keycloak,ou=Services,{SUFFIX}", f"cn=Test,ou=Services,{SUFFIX}", f"cn=Nextcloud,ou=Services,{SUFFIX}",
	 f"uid=test.user,ou=People,{SUFFIX}"])
def test_deny_remove_from_group(bind_dn):
	with LdapConnection(bind_dn, "asd") as conn:
		with pytest.raises(ldap.INSUFFICIENT_ACCESS):
			conn.modify_s(f"cn=Testers,ou=Groups,{SUFFIX}",
				[(ldap.MOD_DELETE, 'member', bytes(f'uid=test.user,ou=People,{SUFFIX}', 'utf8'))])


@pytest.mark.parametrize("bind_dn", [f"cn=Crauto,ou=Services,{SUFFIX}"])
def test_allow_add_to_group(bind_dn):
	target = f'uid=test.hr,ou=People,{SUFFIX}'
	group = f"cn=Testers,ou=Groups,{SUFFIX}"

	target_b = bytes(target, 'utf8')
	group_b = bytes(group, 'utf8')
	with LdapConnection(bind_dn, "asd") as conn:
		result = conn.search_s(group, ldap.SCOPE_BASE, None, ['member'])
		assert target_b not in result[0][1]['member'], 'User is not yet member in group'

		result = conn.search_s(target, ldap.SCOPE_BASE, None, ['memberOf'])
		assert 'memberOf' not in result[0][1] or group_b not in result[0][1]['memberOf'], 'User doesn\'t have memberOf attribute yet'

		conn.modify_s(group, [(ldap.MOD_ADD, 'member', bytes(target, 'utf8'))])

		result = conn.search_s(group, ldap.SCOPE_BASE, None, ['member'])
		assert target_b in result[0][1]['member'], 'User is member in group'

		result = conn.search_s(target, ldap.SCOPE_BASE, None, ['memberOf'])
		assert group_b in result[0][1]['memberOf'], 'User has memberOf attribute'


@pytest.mark.parametrize("bind_dn", [f"cn=Crauto,ou=Services,{SUFFIX}"])
def test_allow_remove_to_group(bind_dn):
	target = f'uid=test.user,ou=People,{SUFFIX}'
	group = f"cn=Testers,ou=Groups,{SUFFIX}"

	target_b = bytes(target, 'utf8')
	group_b = bytes(group, 'utf8')
	with LdapConnection(bind_dn, "asd") as conn:
		result = conn.search_s(group, ldap.SCOPE_BASE, None, ['member'])
		assert target_b in result[0][1]['member'], 'User is member in group'

		result = conn.search_s(target, ldap.SCOPE_BASE, None, ['memberOf'])
		assert group_b in result[0][1]['memberOf'], 'User has memberOf attribute'

		conn.modify_s(group, [(ldap.MOD_DELETE, 'member', bytes(target, 'utf8'))])

		result = conn.search_s(group, ldap.SCOPE_BASE, None, ['member'])
		assert target_b not in result[0][1]['member'], 'User is no longer member in group'

		result = conn.search_s(target, ldap.SCOPE_BASE, None, ['memberOf'])
		assert 'memberOf' not in result[0][1] or group_b not in result[0][1][
			'memberOf'], 'User doesn\'t have memberOf anymore'


def test_password_lockout(example_user_with_password):
	with LdapConnection(f"cn=Directory Manager", PASSWORD) as conn:
		conn.add_s(f"uid=example.user,ou=People,{SUFFIX}", example_user_with_password)
		result = conn.search_s(f"uid=example.user,ou=People,{SUFFIX}", ldap.SCOPE_BASE, None, ['*'])
		assert len(result) > 0, 'User has been added'

	attempts = 0
	with pytest.raises(ldap.CONSTRAINT_VIOLATION):
		for i in range(1, 20):
			try:
				with LdapConnection(f"uid=example.user,ou=People,{SUFFIX}", "invalid"):
					pass
			except ldap.INVALID_CREDENTIALS:
				attempts += 1
	assert attempts == 5, 'Failure after 5 attempts'
